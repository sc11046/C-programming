# 정보 처리기사 공부 자료

<details>
    <summary>1- 소프트웨어 공학의 개념</summary>
1-1) 소프트웨어의 특징<br>
상품성, 복잡성, 변경 가능성, 복제성<br><br>
1-2) 시스템의 개요와 기본요소<br>
입력, 처리, 출력, 제어, 피드백으로 구성(그림 암기)<br>
<img src="https://github.com/sc11046/Capstone/assets/121782720/eb9ab375-6ff5-467d-91f5-93424ca60cf0" width="400" height="300"/><br><br>
1-3) 소프트웨어의 위기<br>
원인 : 개발 비용 증가, 유지 보수 비용<br><br>
2) 소프트웨어 공학<br>
신뢰성 중요<br>
</details>

<details>
    <summary>2- 재공학</summary>
1)재공학<br>
1-1) 소프트웨어 재공학의 장점, 목표, 과정<br>
장점: 프로젝트 실패 위험 감소<br>
목표 유지보수성 향상이 최우선 (잘바꿔서 써먹자)<br>
과정 : 분석->구성->역공학->이식<br><br>
2) 역공학<br>
기존의 있는 것을 재문서화 하는 것<br><br>
3) CASE<br>
소프트엔지니어링을 돕는 자동화 도구<br>
3-1) 기능<br>
개발 신속, 정확 품질 향상<br>
소프트웨어 생명 주기의 전체 단계 연결<br>
시스템의 문서화 및 명세화<br>
개발단계의 표준화<br>
3-2) 장점<br>
비용 절약, 생산성 향상<br>
3-3) 분류<br>
상위 : 요구분석 설계 지원<br>
하위 : 코드 작성, 테스트, 문서화<br>
통합 : 소프트웨어 개발 주기 전체 과정 지원 관리<br><br>
3-4) 요구사항 분석을 위한 CASE도구<br>
SADT : SotfTech사에서 개발 된 CASE를 도와주는 소프트웨어 툴, 시스템 정의, 소프트웨어 요구사항 분석 및 설계 도구, <br>구조적 요구분석을 하기 위해 블록 다이어 그램을 채택하는 자동화 도구<br>
</details>

<details>
    <summary>3- 소프트웨어 개발 방법론</summary>
1) 소프트웨어 설계 방법론<br>
1-1) 소프트웨어 생명주기<br>
타당성 검토-> 개발 계획-> 요구사항 분석-> 설계->구현->테스트->운용->유지보수<br>
1-2) 폭포수 모형의 개요(고전적 생명주기 모형)<br>	
Boehm이 제시, 소규모 소프트웨어 개발에 적합 수정이 어려움<br>
1-3) 나선형 모형 (Spiral 모형) 그림 자주 출제<br>
Boehm이 제시, 위험을 관리하고 최소화가 목적<br>
나선을 따라 돌면서 개발 순서를 반복하여 수행하는 점진적 방식으로 누락된 요구사항을 추가 할 수 있음<br>
<img src="https://github.com/sc11046/Capstone/assets/121782720/977b2ee3-2f45-4f4a-9750-c1e00aa54cbf" width="400" height="300"/><br>
계획 수립-> 위험 분석-> 개발 및 검증-> 고객 평가 <br>
1-4) 하향식과 상향식 설계<br>
하향식 설계 : 제일 상위에 있는 Main User Function에서 시작해 기능을 하위 기능들로 나눠가면서 설계하는 방식 (뿌리->곁가지)<br>
상향식 설계 : 가장 기본적인 컴포넌트를 먼저 설계한 다음 이것을 사용하는 상위 수준의 컴포넌트 설계하는 방식 <br>
1-5) 프로토타입 모형의 개요<br>
개발될 시스템의 견본을 미리 만들어 최종 결과물을 예측하는 모형<br>
개발이 완료되고 문제점을 알 수 있는 폭포수 모형의 단점을 보완하기위한 모형으로 요구사항을 충실히 반영 가능<br>
1- 6) HIPO<br>
입력->처리->출력로 구성되는 시스템 분석 및 설계 시스템 문서화용 기법<br>
가시적 도표(전체적인 기능과 흐름을 볼 수 있음), 총체적 다이어그램, 세부적 다이어그램으로 구성<br>
하향식 소프트웨어 개발을 위한 문서화 도구<br>
1-7) V-모델<br>
폭포수 모형에 시스템 검증과 테스트 작업을 강조한 모델<br>
(그림필수 기억)<br>
<img src="https://github.com/sc11046/Capstone/assets/121782720/7bcc059a-8b6e-4104-ad07-55fece1c8a3e" width="600" height="300"/><br><br>
2) 애자일 개발 방법론<br>
실제로 목표하는대로 만들어 졌는가만 확인하는 방법<br>
종류 : 익스트림 프로그래밍(XP), 스크럼, 린, DSDM, FDD, Crystal, ASD, DAD<br><br>
3) XP<br>
아주 빨리 양질의 소프트웨어 만드는 것<br>
소통, 단순성, 피드백, 용기, 존중<br>
3-1) XP과정<br>
<img src="https://github.com/sc11046/Capstone/assets/121782720/d18b020d-3012-4c11-b7d1-de70f9e0ef33" width="600" height="300"/><br>
Spike : 요구사항 확인<br>
User Stories : 사용자의 요구사항을 시나리오로 표현<br>
Release planing : 몇개의 스토리가 적용되어 부분적으로 기능이 완료된 제품을 제공하는것<br>
iteration : 하나의 릴리즈를 세분화한 단위1~3주 단위로 진행 새로운 요구사항이 들어가는 과정 <br>
Aceeptance Test : 테스트를 통해 만들어지는 것을 확인<br>
Small Release : 작은 단위로 실행할 수 있도록 만드는 것<br>
3-2) XP의 12가지 실천사항<br>
짝프로그래밍 : 한 사람은 개발, 한 사람은 테스트<br>
Planing Game : 게임처럼 선수와 규칙, 목표를 두고 기획<br>
Test Driven : 실제 코드 작성 전 단위 테스트부터 작성 및 수행<br>
Whole Team : 고객 즉 사용자가 프로젝트 팀원으로 속하는 것<br>
Continous integration : 상시 빌드 및 배포상태 유지<br>
Design Improvement : 기븐 변경없이 중복성/복장성 제거<br>
Small Releases : 짧은 주기로 잦은 릴리즈를 함으로써 고객이 변경사항을 볼 수 있게 함<br>
Coding Standards : 소스 코드 작성 포맷과 규칙을 작성<br>
Collective Code Ownership : 팀의 누구라도 코드 수정가능<br>
Simple Design : 가능한 간결한 디자인 상태 유지<br>
Systm Metaphor : 최종적으로 개발되어야 할 시스템의 구조 기술<br>
Sustainable Pace : 개발자에게 너무 과도한 업무 x<br>
3-3) 효과적인 프로젝트 관리를 위한 3대 요소<br>
사람 - 인적 자원<br>
문제 - 문제 인식<br>
프로세스 - 작업 계획<br>
</details>

<details>
    <summary>4- SCRUM</summary>
1) 기본 원리<br>
<img src="https://github.com/sc11046/Capstone/assets/121782720/75ae51e0-74ef-4819-80b3-ced41d234404" width="600" height="300"/><br>
기능 협업을 기준으로 배치된 팀은 스프린트(30일) 단위로 소프트웨어를 개발<br>
요구사항, 아키텍처, 설계가 프로젝트 전반에 걸쳐 잘 나와야함<br><br>
2) 역할<br>
제품 책임자 : 개발 담당자, 요구사항 파악 후 기능 목록 작성, 우선순위 설정<br>
스크럼 마스터 : 업부 배분만 함, 감독의 느낌<br>
스크럼 팀 : 이외 나머지 팀원 기능을 작업 단위로 분류<br>
</details>

<details>
    <summary>5- 현행 시스템 분석</summary>
1)현행 시스템 분석<br>
1-1) 정의와 목적<br>
개발시스템의 개발 범위 이행 방향 확인 가능<br>
1-2) 현행 시스템 파악 절차<br>
1단계 (시스템 구성 파악(회사 조직, 흐름) - 시스템 기능 파악(부서의 대한 기능) )<br>
2단계 (아키텍처(회사의 구성 파악) - 소프트웨어 구성 파악))<br>
3단계 (시스테메 하드웨어 현황 파악 - 네트워크 구성 파악)<br>
1-3) 시스템 아키텍처<br>
시스템 내에서 각각의 구조와 구성 서로 어떻게 움직이는지 짜놓은 것<br>
핵심적인 것이 무엇인지 파악<br>
시스템 전체 구조, 행위, 원리가 어떻게 작동되는지 설명하는 틀 전체적인 조직도<br>
시스템 아키텍처<->소프트웨어 아키텍처 -> 소프트웨어 상세 설계 (상호작용)<br><br>
2) 시스템 및 인터페이스 현황 파악<br>
2-1) 시스템 구성 파악<br>
조직내에 업무를 파악 할 수 있도록 하며, 시스템 내 명칭, 기능 등 주요 기능 명시<br>
2-2) 시스템 기능 파악<br>
각각의 시스템의 기능별로 구분<br>
2-3) 인터페이스 현황 파악<br>
각각의 시스템이 타 단위 업무 시스템과 서로 주고받는 데이터의 연계유형<br>
2-4) EAI<br>
기업 내 모든 어플리케이션 통합 <br>
2-5) FEP(전위처리기)<br>
입력 데이터를 프로세스가 처리하기전에 미리 처리해 시간 단축<br><br>
3) 소프트웨어, 하드웨어, 네트워크 현황 파악<br>
3-1) 소프트웨어 구성 파악<br>
내부의 있는 업무 처리용 소프트웨어의 품명, 용도, 라이선스 방식 파악<br>
3-2) 하드웨어 구성 파악<br>
회사의 설치되어있는 컴퓨터 사양, 서버 이중화 확인<br><br>
4) 플랫폼<br>
기반 시설, 즉 소프트웨어를 만들기 위한 기반<br>
JAVA기반, NET기반 등<br>
4-1) 플랫폼 성능 특성 분석<br>
플랫폼 성능을 파악하고 개선 방향 제시<br>
특성 분석 항목 : 응답 시간. 가용성, 사용률<br>
4-2) 플랫폼 성능 특성 분석 방법<br>
기능테스트 : 현재 시스템 각각의 기능을 테스트<br>
사용자 인터뷰 : 플랫폼의 불편함을 인터뷰<br>
문서 점검 : 플랫폼과 유사한 플랫폼의 기능 자료 분석<br><br>
5) 현행 시스템의 OS분석<br>
안드로이드 기반인지 기반 분석<br>
5-1) 고려사항<br>
분석 항목 : OS종류와 버전, 패치 일자, 백업 주기 분석<br>
고려사항 : 가용성, 성능, 기술 지원, 주변기기, 구축 비용(TCO-돈얼마나 들지)<br>
메모리 누수 : SW가 정상 종료되지 않고 남아 있는 증상<br>
5-2) 오픈소스 라이선스 종류<br>
GNU : 정보를 돈주고 구매하는 것을 반대 ex)리눅스<br>
GUN GPLv1 : 소스 코드를 공개 하지않고 바이너리만 배포하는 것을 금지, 사용하기 쉬운 코드를 같이 배포<br>
BSD : 아무나 개작 가능 수정한 것을 제한 없이 배포 가능<br>
Apache 2.0 :  SW적용을 위해 제공하는 라이선스 ex) HADOOP<br><br>
6) 현행 시스템 DBMS 분석<br>
6-1)DBMS : 데이터 베이스 관리 하는 시스템<br>
종속성(강제해서 끌고 다니는 것)과 중복성의 문제를 해결하기 위해 제안된 시스템<br>
모든 응용 프로그램들이 데이터베이스를 공유 할 수 있도록 관리<br>
6-2) 현행 시스템 DBMS분석<br>
DBMS종류, 버전 등을 분석<br>
6-3) 고려사항<br>
가용성, 성능 기술지원, 상호 호환성, 구축 비용<br>
</details>

<details>
    <summary>6- 요구 사항 개발</summary>
1) 요구사항 개발<br>
요구하는 것을 정확히 파악<br>
1-1) 요구공학<br>
원하는 것을 어떻게 하면 뽑아 낼 수 있는지<br>
자료 흐름도, 자료 사전 등을 활용해 소단위 명세서로 구축 (세분화해서 파악)<br>
1-2) 요구공학 목적<br>
고객과 개발자간의 의사소통의 도구로 활용<br>
누락 방지, 상호 이해 오류 제거<br>
요구사항 변경 이력 관리를 통해 개발 비용 및 시간 절약<br>
1-3) 요구사항 베이스라인<br>
이해 관계자간의 협의에 의해 결정되야함 기준선에 맞게 개발해야됨<br>
1-4) 요구공학 프로세스<br>
요구사항 분석해 검증하는 진행 순서 의미<br>
요구사항을 체계적으로 도출해야됨<br>
결과를 명세서에 정리 <br>
경제성, 기술성, 적법성, 대안성 등 타당성 조사가 선행되어야 함<br>
1-5) SWEBOK에 따른 요구사항 개발 프로세스<br>
요구사항 추출->요구사항 분석->요구사항 명세->요구사항 검증<br>
1-6) 요구사항 도출<br>
소프트웨어가 해결해야되는 문제 이해와 현재 상태 파악<br>
문제 정의 후 문제 해결과 목표를 도출<br>
이해관계자가 식별되며 개발팀과 고객도 포함<br>
요구사항 도출기법(시험 나옴) : 고객의 발표, 문서 조사, 설문, 업무 절차 및 양식 조사,<br>
브레인스토밍, 워크숍, 인터뷰, 관찰 및 모델의 프로토타이핑, Use Case, 벤치마킹, BPR(업무 재설계),RFP(제안요청서)<br>
1-7) 요구사항 분석<br>
요구사항이 실제 무엇인지 걸러내는 단계<br>
요구분석을 위한 기법 : 사용자 의건 청취, 사용자 인터뷰, 현재 사용중인 각종 문서 분석과 중재, 관찰 및 모델 작성 기술, 설문 조사를 통한 의견 수렴<br>
1-8) 요구사항 분석 단계 <br>
문제인식 : 인터뷰, 설문 조사 등 을 활용해 요구 사항 파악<br>
전개 : 파악한 문제를 자세히 조사하는 작업<br>
평가와 종합 : 요구들을 다이어그램이나 자동화 도구를 이용해 종합하는 과정<br>
검토 : 요구분석 작업의 내용을 검토, 재정리하는 과정<br>
문서화 : 요구사항 분석 내용을 문서로 만드는 단계<br>
1-9) 요구사항 분류<br>
기술 내용에 따른 분류 : 기능 요구사항, 비기능(기능을 서포트) 요구사항<br>
1-10) 요구 사항 분류 기준<br>
요구사항 중 우선순위 여부 확인<br>
1-11) 기능적 요구사항 vs 비기능적 요구사항<br>
기능적 요구사항 : 실제로 어떻게 동작하는지 <br>
비기능적 요구사항 : 부수적으로 필요한 것 ,성능, 보안, 품질 , 안정성<br>
1-12) 요구사항 명세 기법<br>
		정형 명세(정해짐)	비정형 명세(안 정해짐)<br>
기법  수학적/모델링 기반		상태/기능/객체 중심 명세 기법, 자연어 기반<br>
종류  Z, VDM,LOTOS,CSP,CCS 	FSM,SADT,USECASE<br>
장점 시스템 요구 특성 간결		명세 작성 이해 용이, 의사소통 방법 다양<br>
단점 낮은 이해도 이해관계자 부담  불충분한 명세 가능 모호성<br>
1-13) 요구사항 명세 속성(시험 가능성)<br>
정확성, 명확성, 완전성, 일관성, 수정 용이성, 추적성<br>
1-14) 요구사항 확인<br>
요구사항 분석 단계이후 문서로 만들어진 내용을 확인하고 검증하는 단계<br>
요구사항 관리 도구의 필요성(시험 가능성) : 요구사항 변경으로 인한 비용 편익 분석, 요구사항 변경의 추적, 변경에 따른 영향 평가<br>
1-15) 형상 관리<br>
개발 단계에서 도출되는 프로그램, 문서, 데이터 등 모든 자료의 변경을 관리 함으로써 버전 관리를 하는 것<br>
1-16) 요구사항 할당<br>
요구사항 분석 후 각각 필요한 위치에 할당<br>
1-17) 정형 분석<br>
구문과 형식적으로 정의된 의미를 지닌 언어로 요구사항 표현<br><br>
2) 요구사항 확인 기법<br>
2-1) 확인 기법 종류<br>
프로토타이핑, 모델 검증, 요구사항 검토, 인수 테스트<br>
2-2) 프로토 타이핑<br>
요구사항을 토대로 프로토타입을 제작해 대상 시스템과 비교하면서 개발 중에 도출되는 요구사항을 재작성<br>
절차 : 요구사항 분석 단계-> 프로토타입 설계단계 -> 프로토타입 개발 단계-> 고객의 평가 단계-> 프로토타입 정제 단계->완제품 생산 단계<br>
장점 : 피드백 가능, 빠른 반복 제작을 통해 발전 가능<br>
단점 : 품질이 구림, 비용 발생<br>
2-3) 모델 검증<br>
모델의 품질을 검증<br>
정적 분석: 코드 확인, 일관성있는지 확인<br>
동적 분석: 실행 해서 확인<br>
2-4) 인수 테스트<br>
실제 고객에게 전달하고 요구사항이 맞는지 확인<br>
종류 : 계약 인수, 규정 인수, 알파 검사, 베타 검사, 사용자 인수 테스트 , 운영 인수 테스트<br>
</details>







