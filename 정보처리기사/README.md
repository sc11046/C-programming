# 정보 처리기사 공부 자료

<details>
    <summary>1- 소프트웨어 공학의 개념</summary>
1-1) 소프트웨어의 특징<br>
상품성, 복잡성, 변경 가능성, 복제성<br><br>
1-2) 시스템의 개요와 기본요소<br>
입력, 처리, 출력, 제어, 피드백으로 구성(그림 암기)<br>
<img src="https://github.com/sc11046/Capstone/assets/121782720/eb9ab375-6ff5-467d-91f5-93424ca60cf0" width="400" height="300"/><br><br>
1-3) 소프트웨어의 위기<br>
원인 : 개발 비용 증가, 유지 보수 비용<br><br>
2) 소프트웨어 공학<br>
신뢰성 중요<br>
</details>

<details>
    <summary>2- 재공학</summary>
1)재공학<br>
1-1) 소프트웨어 재공학의 장점, 목표, 과정<br>
장점: 프로젝트 실패 위험 감소<br>
목표 유지보수성 향상이 최우선 (잘바꿔서 써먹자)<br>
과정 : 분석->구성->역공학->이식<br><br>
2) 역공학<br>
기존의 있는 것을 재문서화 하는 것<br><br>
3) CASE<br>
소프트엔지니어링을 돕는 자동화 도구<br>
3-1) 기능<br>
개발 신속, 정확 품질 향상<br>
소프트웨어 생명 주기의 전체 단계 연결<br>
시스템의 문서화 및 명세화<br>
개발단계의 표준화<br>
3-2) 장점<br>
비용 절약, 생산성 향상<br>
3-3) 분류<br>
상위 : 요구분석 설계 지원<br>
하위 : 코드 작성, 테스트, 문서화<br>
통합 : 소프트웨어 개발 주기 전체 과정 지원 관리<br><br>
3-4) 요구사항 분석을 위한 CASE도구<br>
SADT : SotfTech사에서 개발 된 CASE를 도와주는 소프트웨어 툴, 시스템 정의, 소프트웨어 요구사항 분석 및 설계 도구, <br>구조적 요구분석을 하기 위해 블록 다이어 그램을 채택하는 자동화 도구<br>
</details>

<details>
    <summary>3- 소프트웨어 개발 방법론</summary>
1) 소프트웨어 설계 방법론<br>
1-1) 소프트웨어 생명주기<br>
타당성 검토-> 개발 계획-> 요구사항 분석-> 설계->구현->테스트->운용->유지보수<br>
1-2) 폭포수 모형의 개요(고전적 생명주기 모형)<br>	
Boehm이 제시, 소규모 소프트웨어 개발에 적합 수정이 어려움<br>
1-3) 나선형 모형 (Spiral 모형) 그림 자주 출제<br>
Boehm이 제시, 위험을 관리하고 최소화가 목적<br>
나선을 따라 돌면서 개발 순서를 반복하여 수행하는 점진적 방식으로 누락된 요구사항을 추가 할 수 있음<br>
<img src="https://github.com/sc11046/Capstone/assets/121782720/977b2ee3-2f45-4f4a-9750-c1e00aa54cbf" width="400" height="300"/><br>
계획 수립-> 위험 분석-> 개발 및 검증-> 고객 평가 <br>
1-4) 하향식과 상향식 설계<br>
하향식 설계 : 제일 상위에 있는 Main User Function에서 시작해 기능을 하위 기능들로 나눠가면서 설계하는 방식 (뿌리->곁가지)<br>
상향식 설계 : 가장 기본적인 컴포넌트를 먼저 설계한 다음 이것을 사용하는 상위 수준의 컴포넌트 설계하는 방식 <br>
1-5) 프로토타입 모형의 개요<br>
개발될 시스템의 견본을 미리 만들어 최종 결과물을 예측하는 모형<br>
개발이 완료되고 문제점을 알 수 있는 폭포수 모형의 단점을 보완하기위한 모형으로 요구사항을 충실히 반영 가능<br>
1- 6) HIPO<br>
입력->처리->출력로 구성되는 시스템 분석 및 설계 시스템 문서화용 기법<br>
가시적 도표(전체적인 기능과 흐름을 볼 수 있음), 총체적 다이어그램, 세부적 다이어그램으로 구성<br>
하향식 소프트웨어 개발을 위한 문서화 도구<br>
1-7) V-모델<br>
폭포수 모형에 시스템 검증과 테스트 작업을 강조한 모델<br>
(그림필수 기억)<br>
<img src="https://github.com/sc11046/Capstone/assets/121782720/7bcc059a-8b6e-4104-ad07-55fece1c8a3e" width="600" height="300"/><br><br>
2) 애자일 개발 방법론<br>
실제로 목표하는대로 만들어 졌는가만 확인하는 방법<br>
종류 : 익스트림 프로그래밍(XP), 스크럼, 린, DSDM, FDD, Crystal, ASD, DAD<br><br>
3) XP<br>
아주 빨리 양질의 소프트웨어 만드는 것<br>
소통, 단순성, 피드백, 용기, 존중<br>
3-1) XP과정<br>
<img src="https://github.com/sc11046/Capstone/assets/121782720/d18b020d-3012-4c11-b7d1-de70f9e0ef33" width="600" height="300"/><br>
Spike : 요구사항 확인<br>
User Stories : 사용자의 요구사항을 시나리오로 표현<br>
Release planing : 몇개의 스토리가 적용되어 부분적으로 기능이 완료된 제품을 제공하는것<br>
iteration : 하나의 릴리즈를 세분화한 단위1~3주 단위로 진행 새로운 요구사항이 들어가는 과정 <br>
Aceeptance Test : 테스트를 통해 만들어지는 것을 확인<br>
Small Release : 작은 단위로 실행할 수 있도록 만드는 것<br>
3-2) XP의 12가지 실천사항<br>
짝프로그래밍 : 한 사람은 개발, 한 사람은 테스트<br>
Planing Game : 게임처럼 선수와 규칙, 목표를 두고 기획<br>
Test Driven : 실제 코드 작성 전 단위 테스트부터 작성 및 수행<br>
Whole Team : 고객 즉 사용자가 프로젝트 팀원으로 속하는 것<br>
Continous integration : 상시 빌드 및 배포상태 유지<br>
Design Improvement : 기븐 변경없이 중복성/복장성 제거<br>
Small Releases : 짧은 주기로 잦은 릴리즈를 함으로써 고객이 변경사항을 볼 수 있게 함<br>
Coding Standards : 소스 코드 작성 포맷과 규칙을 작성<br>
Collective Code Ownership : 팀의 누구라도 코드 수정가능<br>
Simple Design : 가능한 간결한 디자인 상태 유지<br>
Systm Metaphor : 최종적으로 개발되어야 할 시스템의 구조 기술<br>
Sustainable Pace : 개발자에게 너무 과도한 업무 x<br>
3-3) 효과적인 프로젝트 관리를 위한 3대 요소<br>
사람 - 인적 자원<br>
문제 - 문제 인식<br>
프로세스 - 작업 계획<br>
</details>

<details>
    <summary>4- SCRUM</summary>
1) 기본 원리<br>
<img src="https://github.com/sc11046/Capstone/assets/121782720/75ae51e0-74ef-4819-80b3-ced41d234404" width="600" height="300"/><br>
기능 협업을 기준으로 배치된 팀은 스프린트(30일) 단위로 소프트웨어를 개발<br>
요구사항, 아키텍처, 설계가 프로젝트 전반에 걸쳐 잘 나와야함<br><br>
2) 역할<br>
제품 책임자 : 개발 담당자, 요구사항 파악 후 기능 목록 작성, 우선순위 설정<br>
스크럼 마스터 : 업부 배분만 함, 감독의 느낌<br>
스크럼 팀 : 이외 나머지 팀원 기능을 작업 단위로 분류<br>
</details>

<details>
    <summary>5- 현행 시스템 분석</summary>
1)현행 시스템 분석<br>
1-1) 정의와 목적<br>
개발시스템의 개발 범위 이행 방향 확인 가능<br>
1-2) 현행 시스템 파악 절차<br>
1단계 (시스템 구성 파악(회사 조직, 흐름) - 시스템 기능 파악(부서의 대한 기능) )<br>
2단계 (아키텍처(회사의 구성 파악) - 소프트웨어 구성 파악))<br>
3단계 (시스테메 하드웨어 현황 파악 - 네트워크 구성 파악)<br>
1-3) 시스템 아키텍처<br>
시스템 내에서 각각의 구조와 구성 서로 어떻게 움직이는지 짜놓은 것<br>
핵심적인 것이 무엇인지 파악<br>
시스템 전체 구조, 행위, 원리가 어떻게 작동되는지 설명하는 틀 전체적인 조직도<br>
시스템 아키텍처<->소프트웨어 아키텍처 -> 소프트웨어 상세 설계 (상호작용)<br><br>
2) 시스템 및 인터페이스 현황 파악<br>
2-1) 시스템 구성 파악<br>
조직내에 업무를 파악 할 수 있도록 하며, 시스템 내 명칭, 기능 등 주요 기능 명시<br>
2-2) 시스템 기능 파악<br>
각각의 시스템의 기능별로 구분<br>
2-3) 인터페이스 현황 파악<br>
각각의 시스템이 타 단위 업무 시스템과 서로 주고받는 데이터의 연계유형<br>
2-4) EAI<br>
기업 내 모든 어플리케이션 통합 <br>
2-5) FEP(전위처리기)<br>
입력 데이터를 프로세스가 처리하기전에 미리 처리해 시간 단축<br><br>
3) 소프트웨어, 하드웨어, 네트워크 현황 파악<br>
3-1) 소프트웨어 구성 파악<br>
내부의 있는 업무 처리용 소프트웨어의 품명, 용도, 라이선스 방식 파악<br>
3-2) 하드웨어 구성 파악<br>
회사의 설치되어있는 컴퓨터 사양, 서버 이중화 확인<br><br>
4) 플랫폼<br>
기반 시설, 즉 소프트웨어를 만들기 위한 기반<br>
JAVA기반, NET기반 등<br>
4-1) 플랫폼 성능 특성 분석<br>
플랫폼 성능을 파악하고 개선 방향 제시<br>
특성 분석 항목 : 응답 시간. 가용성, 사용률<br>
4-2) 플랫폼 성능 특성 분석 방법<br>
기능테스트 : 현재 시스템 각각의 기능을 테스트<br>
사용자 인터뷰 : 플랫폼의 불편함을 인터뷰<br>
문서 점검 : 플랫폼과 유사한 플랫폼의 기능 자료 분석<br><br>
5) 현행 시스템의 OS분석<br>
안드로이드 기반인지 기반 분석<br>
5-1) 고려사항<br>
분석 항목 : OS종류와 버전, 패치 일자, 백업 주기 분석<br>
고려사항 : 가용성, 성능, 기술 지원, 주변기기, 구축 비용(TCO-돈얼마나 들지)<br>
메모리 누수 : SW가 정상 종료되지 않고 남아 있는 증상<br>
5-2) 오픈소스 라이선스 종류<br>
GNU : 정보를 돈주고 구매하는 것을 반대 ex)리눅스<br>
GUN GPLv1 : 소스 코드를 공개 하지않고 바이너리만 배포하는 것을 금지, 사용하기 쉬운 코드를 같이 배포<br>
BSD : 아무나 개작 가능 수정한 것을 제한 없이 배포 가능<br>
Apache 2.0 :  SW적용을 위해 제공하는 라이선스 ex) HADOOP<br><br>
6) 현행 시스템 DBMS 분석<br>
6-1)DBMS : 데이터 베이스 관리 하는 시스템<br>
종속성(강제해서 끌고 다니는 것)과 중복성의 문제를 해결하기 위해 제안된 시스템<br>
모든 응용 프로그램들이 데이터베이스를 공유 할 수 있도록 관리<br>
6-2) 현행 시스템 DBMS분석<br>
DBMS종류, 버전 등을 분석<br>
6-3) 고려사항<br>
가용성, 성능 기술지원, 상호 호환성, 구축 비용<br>
</details>

<details>
    <summary>6- 요구 사항 개발</summary>
1) 요구사항 개발<br>
요구하는 것을 정확히 파악<br>
1-1) 요구공학<br>
원하는 것을 어떻게 하면 뽑아 낼 수 있는지<br>
자료 흐름도, 자료 사전 등을 활용해 소단위 명세서로 구축 (세분화해서 파악)<br>
1-2) 요구공학 목적<br>
고객과 개발자간의 의사소통의 도구로 활용<br>
누락 방지, 상호 이해 오류 제거<br>
요구사항 변경 이력 관리를 통해 개발 비용 및 시간 절약<br>
1-3) 요구사항 베이스라인<br>
이해 관계자간의 협의에 의해 결정되야함 기준선에 맞게 개발해야됨<br>
1-4) 요구공학 프로세스<br>
요구사항 분석해 검증하는 진행 순서 의미<br>
요구사항을 체계적으로 도출해야됨<br>
결과를 명세서에 정리 <br>
경제성, 기술성, 적법성, 대안성 등 타당성 조사가 선행되어야 함<br>
1-5) SWEBOK에 따른 요구사항 개발 프로세스<br>
요구사항 추출->요구사항 분석->요구사항 명세->요구사항 검증<br>
1-6) 요구사항 도출<br>
소프트웨어가 해결해야되는 문제 이해와 현재 상태 파악<br>
문제 정의 후 문제 해결과 목표를 도출<br>
이해관계자가 식별되며 개발팀과 고객도 포함<br>
요구사항 도출기법(시험 나옴) : 고객의 발표, 문서 조사, 설문, 업무 절차 및 양식 조사,<br>
브레인스토밍, 워크숍, 인터뷰, 관찰 및 모델의 프로토타이핑, Use Case, 벤치마킹, BPR(업무 재설계),RFP(제안요청서)<br>
1-7) 요구사항 분석<br>
요구사항이 실제 무엇인지 걸러내는 단계<br>
요구분석을 위한 기법 : 사용자 의건 청취, 사용자 인터뷰, 현재 사용중인 각종 문서 분석과 중재, 관찰 및 모델 작성 기술, 설문 조사를 통한 의견 수렴<br>
1-8) 요구사항 분석 단계 <br>
문제인식 : 인터뷰, 설문 조사 등 을 활용해 요구 사항 파악<br>
전개 : 파악한 문제를 자세히 조사하는 작업<br>
평가와 종합 : 요구들을 다이어그램이나 자동화 도구를 이용해 종합하는 과정<br>
검토 : 요구분석 작업의 내용을 검토, 재정리하는 과정<br>
문서화 : 요구사항 분석 내용을 문서로 만드는 단계<br>
1-9) 요구사항 분류<br>
기술 내용에 따른 분류 : 기능 요구사항, 비기능(기능을 서포트) 요구사항<br>
1-10) 요구 사항 분류 기준<br>
요구사항 중 우선순위 여부 확인<br>
1-11) 기능적 요구사항 vs 비기능적 요구사항<br>
기능적 요구사항 : 실제로 어떻게 동작하는지 <br>
비기능적 요구사항 : 부수적으로 필요한 것 ,성능, 보안, 품질 , 안정성<br>
1-12) 요구사항 명세 기법<br>
		정형 명세(정해짐)	비정형 명세(안 정해짐)<br>
기법  수학적/모델링 기반		상태/기능/객체 중심 명세 기법, 자연어 기반<br>
종류  Z, VDM,LOTOS,CSP,CCS 	FSM,SADT,USECASE<br>
장점 시스템 요구 특성 간결		명세 작성 이해 용이, 의사소통 방법 다양<br>
단점 낮은 이해도 이해관계자 부담  불충분한 명세 가능 모호성<br>
1-13) 요구사항 명세 속성(시험 가능성)<br>
정확성, 명확성, 완전성, 일관성, 수정 용이성, 추적성<br>
1-14) 요구사항 확인<br>
요구사항 분석 단계이후 문서로 만들어진 내용을 확인하고 검증하는 단계<br>
요구사항 관리 도구의 필요성(시험 가능성) : 요구사항 변경으로 인한 비용 편익 분석, 요구사항 변경의 추적, 변경에 따른 영향 평가<br>
1-15) 형상 관리<br>
개발 단계에서 도출되는 프로그램, 문서, 데이터 등 모든 자료의 변경을 관리 함으로써 버전 관리를 하는 것<br>
1-16) 요구사항 할당<br>
요구사항 분석 후 각각 필요한 위치에 할당<br>
1-17) 정형 분석<br>
구문과 형식적으로 정의된 의미를 지닌 언어로 요구사항 표현<br><br>
2) 요구사항 확인 기법<br>
2-1) 확인 기법 종류<br>
프로토타이핑, 모델 검증, 요구사항 검토, 인수 테스트<br>
2-2) 프로토 타이핑<br>
요구사항을 토대로 프로토타입을 제작해 대상 시스템과 비교하면서 개발 중에 도출되는 요구사항을 재작성<br>
절차 : 요구사항 분석 단계-> 프로토타입 설계단계 -> 프로토타입 개발 단계-> 고객의 평가 단계-> 프로토타입 정제 단계->완제품 생산 단계<br>
장점 : 피드백 가능, 빠른 반복 제작을 통해 발전 가능<br>
단점 : 품질이 구림, 비용 발생<br>
2-3) 모델 검증<br>
모델의 품질을 검증<br>
정적 분석: 코드 확인, 일관성있는지 확인<br>
동적 분석: 실행 해서 확인<br>
2-4) 인수 테스트<br>
실제 고객에게 전달하고 요구사항이 맞는지 확인<br>
종류 : 계약 인수, 규정 인수, 알파 검사, 베타 검사, 사용자 인수 테스트 , 운영 인수 테스트<br>
</details>
<details>
    <summary>7- UML</summary>
1-1) 개념 모델링<br>
요구사항을 이해하기 쉽도록 상황을 단순화해 개념적으로 표현한 것을 모델이라하고 모델을 생성해 나가는 과정을 개념<br>
종류 : Use Case Diagram, Data Flow Model, State Model, Goal-Based Model, User Interactions, Object Model, Data Model<br>
1-2) UML<br>
객체지향 소프트웨어 개발 과정에서 시스템 분석, 설계, 구현 등의 산출물을 명세화, 시각화, 문서화 할 때 사용하는 모델링 기술과 방법론을 통합하여 만든 범용 모델링 언어<br>
1-3) 럼바우 객체지향 분석 기법<br>
객체 모델링 : 대상체를 모델링 ex) 학교에 있는 학생, 객체 다이어 그램으로 표시<br>
동적 모델링 : 상호작용, 동작 순서 등의 상태를 흐름에 따라 상태 다이어그램으로 표시<br>
기능 모델링 : 자료의 흐름을 표시하는 것<br>
1-4) UML의 특성<br>
비주얼화, 문서화, 명세화, 구축<br>
1-5) UML 소프트웨어에 대한 관점<br>
기능적 관점 : 사용자 측면에서 어떻게 움직이는지에 대한 사례 모델링ex) Use Case Diagram<br>
정적 관점 : 객체 사이의 구조적 관계를 나타냄 ex) Class Diagramg<br>
동적 관점 : 시스템 내부의 동작을 나타냄 ex) Sequence, State, Activity Diagram<br>
1-6) UML의 기본 구성<br>
사물 : 객체지향 모델을 구성하는 기본 요소<br>
관계 : 객체 간의 연관성을 표현하는 것<br>
다이어그램 : 객체의 관계를 도식화 구조다이어그램, 행위 다이어그램<br>
1-7) 스테레오 타입<br>
기본 요소 외에 추가적인 확장 요소 표현<br>
UML 확장 모델에서 스테레오 타입 객체를 표현할 때 사용하는 기호 <<,>><br>
1-8) UML 접근 제어자<br>
Public(+) : 어떤 클래스의 객체에서 든 접근 가능<br>
Private(-) : 해당 클래스로 생성된 객체만 접근 가능<br>
Protected (#) : 동일 패키지에 있거나 상속 관계에 있는 하위 클래스의 객체들만 접근가능<br>
Package (~) : 동일 패키지에 있는 객체만 접근 가능<br><br>
2) UML 다이어그램의 종류<br>
2-1) 구조적 다이어그램<br>
정적이고, 구조 표현을 위한 다이어 그램<br>
다이어그램 유형 |  목적<br>
-----------------------------<br>
클래스 다이어그램 | 정적 구조<br>
객체 다이어그램 | 객체 정보 표시<br>
복합체 구조 다이어그램 | 복합 구조의 클래스와 컴포넌트 내부 구조 표현<br>
배치 다이어그램 | 실행 시스템의 물리 구조 표현<br>
컴포넌트 다이어그램 | 컴포넌트 구조 사이의 관계 표현<br>
패키지 다이어그램 | 그룹화해 패키지를 구성하고 패키지 사이 관계 표현<br>
2-2) 행위 다이어그램<br>
다이어그램 유형 |  목적<br>
-----------------------------<br>
유스케이스 다이어그램 | 사용자 관점에서 시스템 행위 표현<br>
활동 다이어그램 | 업무 처리 과정이나 연산이 수행되는 과정 표현<br>
상태 머신 다이어그램 | 객체의 생명주기 표현<br>
콜라보레이션 다이어그램 | 공간 제약이 없어 구조적인 면을 중시<br>
(동적)<br>
순차 다이어그램(생명선, 통로, 상호작용, 발생, 실행,상태 불변, 메시지, 활성 객체)<br>
상호작용 개요 다이어그램, 통신 다이어그램, 타이밍 다이어그램 <br><br>
3) 클래스 다이어그램 관계 표현<br>
3-1) 클래스 다이어그램 (그림 기억)<br>
<img src="https://github.com/sc11046/programming/assets/121782720/e5798e86-ad1e-477d-b780-2a652d003759" width="400"height="300"/><br>
시스템 구성하는 객체 간의 관계 추상화<br>
3-2) UML 관계 표현 (그림 기억) 1:28 (일반화 관계 기억)<br>
<img src="https://github.com/sc11046/programming/assets/121782720/95202c68-b674-4e84-8ebe-50868b0e3268" width="400"height="300"/>
<img src="https://github.com/sc11046/programming/assets/121782720/69f73ed3-4737-4092-a6da-dbb73dfa4012" width="400"height="300"/><br>
3-3) UML 연관 관계 (그림 기억)<br>
사물의 객체가 다른 사물의 객체와 어떻게 연결됬는지 표현<br>
<img src="https://github.com/sc11046/programming/assets/121782720/add18635-f553-443e-9d32-f76474d47e93" width="400"height="300"/><br>
3-4) UML 의존 관계<br>
연관 관계는 같지만 메소드를 사용할 때와 같이 매우 짧은 시간만 유지<br>
3-5) UML 일반화 관계<br>
객체지향에서 상속 관계를 표현<br>
3-6) UML 집합 관계<br>
A객체가 B객체에 포함된 관계<br>
3-7) UML 포함 관계<br>
ex)책상은 다리와 상판으로 구성<br>
3-8) UML 실체화 관계<br>
인터페이스와 실제 구현된 일반 클래스 간의 관계로 존재하는 행동에 대한 구현을 표현<br><br>
4) Use Case 다이어그램<br>
4-1) Use Case 다이어그램 개념<br>
각각의 액터들이 어떤 행위를 갖는지 도식화 한 것<br>
4-2) Use Case 다이어그램 요소<br>
시스템 경계 : 큰 규모의 객체로 구현되는 존재<br>
액터 : 서비스를 이용하는 외부객체<br>
유스케이스 : 시스템이 제공해야 하는 개별적인 서비스 기능<br>
접속 관계 : 액터/유스케이스 또는 유스케이스/유케이스 사이에 연결되는 관계<br>
사용 관계 : 여러 개의 유스케이스에서 공통으로 수행해야 하는 기능을 모델링하기 위해 사용<br>
확장 관계 : 확장 기능 유스케이스와 확당 대상 유스케이스 사이에 형성되는 관계<br>
4-3) Use Case 다이어그램 작성 단계<br>
액터식별->Use Case 식별(액터 요구 사항 식별)-> 관계 정의(액터와 유스케이스의 관계 식별<br>
-> Use Case 구조화(두 개의 상위 Use Case에 존재하는 공통 서비스 추출)<br>
</details>

<details>
    <summary>8- 소프트웨어 아키텍처</summary>
1) 소프트웨어 아키텍처<br>
1-1) 소프트웨어 아키텍처<br>
개발 대상의 시스템을 전반적인 구조로 전체적으로 설계하는 것<br>
1-2) 품질 요구사항<br>
기능, 성능, 만족도 등 요구사항을 얼마나 충족하는가<br>
1-3) ISO/IEC 9126 모델 (사진 기억)<br>
<img src="https://github.com/sc11046/programming/assets/121782720/1f5e72c6-f767-4bd8-9dc0-4fe73d2d34fa" width="900"height="400"/><br>
품질 평가 국제 표준 기준<br>
내외부 품질 : 기능성, 신뢰성, 사용성, 효율성, 유지보수성, 이식성<br>
사용 품질 : 효과성, 생산성, 안정성, 만족도<br>
외부 지표 : 사용자나 평가자를 기준으로 지표를 만들어내는 것<br>
내부 지표 : 설계나 코딩쪽의 표준 품질 평가<br>
->내/외부 품질과 사용 품질 구분 문제 나옴(기신사효유이)<br><br>
2) UI 표준을 위한 환경 분석<br>
2-1) 사용자 경향 분석<br>
현재 UI 단점 작성, 요구사항 파악<br>
2-2) 기능 및 설계 분석<br>
기능 조작성 분석 : 사용자 편의를 위한 조작에 관한 분석 확인<br>
오류 방지 분석 : 조작시 오류에 대해 예상 가능한지 확인<br>
최소한의 조작으로 업무 처리 가능한 형태 분석 : 가장 적합한 레이아웃 인지 확인<br>
UI 정보 전달력 확인 : 중요 정보 인지, 쉽게 전달 가능한지, 간결성, 명확성 확인<br>
2-3) 요구사항 요소<br>
데이터 요구, 기능 요구, 제품 서비스 품질, 제약 사항<br>
2-4) 정황 시나리오 작성<br>
서비스 초기 모양 상상하는 단계<br>
가장 기초적인 시나리오 <br>
</details>

<details>
    <summary>9- UI 표준 및 지침</summary>
1) UI 표준 및 지침<br>
1-1) UI<br>
인간, 디지털 기기, 소프트웨어 사이에서 의사소통 할 수 있도록 만들어진 매개체<br>
1-2) UI 분야 <br>
표현에 관한 분야 : 전체적인 구성과 콘텐츠의 상세 표현을 위한 분야<br>
정보 제공과 전달 분야 : 물리적 제어를 통한 정보 제공과 전달을 위한 분야<br>
기능 분야 : 기능적으로 사용자가 쉽고 간편하게 사용하도록 하는 분야<br>
1-3) Ui특징<br>
만족도에 직접적 영향, 업무 효율성 높일 수 있음<br>
1-4) UI 개발 시스템이 가져야 할 기능<br>
사용자 입력의 검증<br>
에러처리와 에러 메시지 처리<br>
도움과 프롬포트(입력창)제공<br><br>
2) UI 설계<br>
2-1) UI 설계 원칙<br>
직관성 : 누구나 쉽게 이해하고 사용할 수 있도록 <br>
유효성 : 사용자의 목적을 정확히 달성하도록 유용하고 효과적이어야 함<br>
학습성 : 사용자가 쉽게 배우고 익힐 수 있어야 함<br>
유연성 : 사용자의 요구를 충분히 수용 가능해야함<br>
2-2) UI 설계 필요성<br>
오류 최소화, 적은 노력, 일에 대하여 구체적 방법 제시<br>
2-3) UI 설계 지침<br>
사용자 중심, 일관성, 단순성, 가시성, 표준화, 접근성, 결과 예측 가능, 명확성, 오류 발생 해결<br><br>
3) UI 표준<br>
3-1) UI 구현 표준<br>
협업시 최소한 UI 요소 및 배치 규칙 등의 규칙을 의미<br>
3-2) 한국형 웹 콘텐츠 접근성 지침 2.1 4가지 원칙<br>
인식의 용이성, 운용의 용이성, 이해의 용이성, 견고성<br><br>
4) UX<br>
4-1) UX 사용자 경험<br>
사용자가 경험을 통해 감정적으로 느끼는 것<br>
4-2) 고려사항<br>
대상, 환경, 목적, 빈도 등을 고려<br>
</details>

<details>
    <summary>10- UI 설계</summary>
1) UI 설계 단계<br>
1-1) UI 설계 단계<br>
문제 정의 ->사용자 모델 정의 ->작업 분석-> 컴퓨터 오브젝트 및 기능 정의 -> 사용자 인터페이스 정의 -> 디자인 평가<br>
1-2) UI 상세 설계 단계<br>
UI 메뉴 구조 설계 -> 내/외부 화면과 폼 설계 -> UI 검토 수행<br>
1-3) UI상세 설계- 시나리오 작성 원칙<br>
시나리오에 맞게 필요한 기능 분석(Flowchart 사용)<br>
작성 요건 : 완전성, 일관성, 이해성, 가독성, 수정 용이성, 추적 용이성<br><br>
2) UI 설계 도구<br>
2-1) UI설계에 도움을 주는 도구들<br>
와이어 프레임 : UI중심의 화면 레이아웃을 선을 이용해서 개략적으로 작성<br>
목업 : 실물과 흡사한 정적인 모형을 의미<br>
프로토 타입 : 상호작용이 결합하여 실제 작동하는 모형<br>
스토리보드 : 정책, 프로세스, 와이어 프레임, 설명이 모두 포함된 설계 문서<br>
2-2) 와이어 프레임<br>
기획 초기에 작성, 대략적인 레이아웃 UI요소 설계<br>
툴 : 핸드라이팅, 파워포인트, 키노트, 스케치, 카카오 오븐<br>
2-3) 목업<br>
실제 작품과 유사하게 만드는 것<br>
툴 : 카카오 오븐, Power Mockup<br>
2-4) 스토리보드<br>
UI/UX 구현에 수반되는 사용자와 작업, 인터페이스 간 상호 작용을 시각화 한 것<br><br>
3) UI 프로토타입<br>
3-1) 프로토타입<br>
도출된 요구사항을 시제품으로 만들어 낸것<br>
3-2) 프로토타입 장단점<br>
장점 : 사용자 설득과 이해가 쉽다 개발 시간 감소<br>
단점 : 수정이 많아지면 작업 시간 증가, 필요 이상으로 자원 소비<br><br>
4) 감성공학<br>
사람의 감정의 공학적 접근<br>
4-1) 감성 공학 접근 방법<br>
1류 : 인간의 감각, 감성을 표현하는 어휘를 이요해 제품에 대한 이미지를 분석, 디자인 요소에 연계하는 접근 방법<br>
2류 : 1류와 기본틀을 공유하고, 감성 어휘 수집, 생황 양식을 추가<br>
3류 : 감각 척도로 감성을 표출하는 방법<br>
4-2) HCI<br>
인간과 컴퓨터와 상호작용하는 것<br>
4-3) 감성 공학 요소 기술<br>
기초 기술, 구현 기술, 응용 기술<br><br>
</details>

